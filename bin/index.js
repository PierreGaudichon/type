// Generated by CoffeeScript 1.8.0
(function() {
  var clone, isArray, isFunction, isPlainObject, map, t, _ref;

  _ref = require("lodash"), isPlainObject = _ref.isPlainObject, isFunction = _ref.isFunction, isArray = _ref.isArray, map = _ref.map, clone = _ref.clone;

  module.exports = t = {};

  t.args = function(a) {
    return Array.prototype.slice.call(a);
  };

  t.type = function(fun) {
    var ret;
    ret = function() {
      return fun.apply(null, arguments);
    };
    ret.nbArguments = fun.length;
    return ret;
  };

  t.extend = function(type, fun) {
    return function() {
      var args, base, baseArgs, ext, extArgs, k, v;
      args = t.args(arguments);
      baseArgs = args.slice(0, args.length - type.nbArguments);
      extArgs = args.slice(type.nbArguments);
      base = type.apply(null, baseArgs);
      ext = fun.apply(null, extArgs);
      for (k in base) {
        v = base[k];
        if (ext[k] == null) {
          ext[k] = v;
        }
      }
      return ext;
    };
  };


  /*
   * First implementation, work for function but skip properties.
  t.iterator = () ->
  	args = t.args arguments
  	ret = {}
  
  	 * We parcours all the functions arguments
  	for a in args
  		 * For each of thoses arguments we parcours it's internal
  		 * propeties.
  		for k, v of a
  			 * And then, when the propertie is a function and is unset
  			 * in the returned object,
  			if (not ret[k]?) and isFunction v
  				 * we assign a function to that value in the
  				 * returned object. The wrapper (do ->) is there
  				 * to keep track of the property name.
  				ret[k] = do(k) -> () ->
  					 * At each call of the iterator method, we parcours
  					 * the arguments again. And when the method exists,
  					for a in args when a[k]?
  						 * we call it.
  						a[k].apply a, arguments
  
  			else if (not ret[k]?) and (not isFunction v)
  				ret[k] = [v]
  			else if (not isFunction v)
  				ret[k].push v
  
  	 *console.log ret
  	 *for k, v of ret
  		 *ret[k] = t.iterator.apply null, v if isArray v
  
  
  	 * Finnaly we return the iterator object.
  	 * If everything is ok, that object contains all methods
  	 * callables in the objects we passed to the t.iterator
  	 * function.
  	return ret
   */

  t.iterator = function() {
    var a, allProperties, args, k, prop, protoArr, ret, v, _i, _j, _len, _len1;
    args = t.args(arguments);
    allProperties = [];
    ret = function() {
      return args;
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      for (k in a) {
        v = a[k];
        allProperties.push(k);
      }
      protoArr = Object.getOwnPropertyNames(a.__proto__);
      allProperties = allProperties.concat(protoArr);
    }
    for (_j = 0, _len1 = allProperties.length; _j < _len1; _j++) {
      prop = allProperties[_j];
      if (ret[prop] == null) {
        ret[prop] = (function(prop) {
          return function() {
            var r;
            r = (function() {
              var _k, _len2, _results;
              _results = [];
              for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
                a = args[_k];
                if (a[prop] != null) {
                  if (isFunction(a[prop])) {
                    _results.push(a[prop].apply(a, arguments));
                  } else {
                    _results.push(a[prop]);
                  }
                }
              }
              return _results;
            }).apply(this, arguments);
            return t.iterator.apply(null, r);
          };
        })(prop);
      }
    }
    return ret;
  };

}).call(this);
